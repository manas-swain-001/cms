const express = require('express');
const { body, validationResult, query } = require('express-validator');
const { User } = require('../models/User');
const { auth, authorize, checkPermission, selfOrAdmin, managerAccess, auditLog } = require('../middleware/auth');
const upload = require('../middleware/upload');
const { USER_ROLES } = require('../constant/enum');

const router = express.Router();

// @route   POST /api/users/save
// @desc    Register a new user
// @access  Private (Admin only)
router.post('/save', [
  auth,
  authorize(USER_ROLES.ADMIN),
  body('firstName')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('First name must be between 2 and 50 characters'),
  body('lastName')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Last name must be between 2 and 50 characters'),
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Please provide a valid email'),
  body('password')
    .isLength({ min: 6 })
    .withMessage('Password must be at least 6 characters long')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, and one number'),
  body('role')
    .optional()
    .isIn(Object.values(USER_ROLES))
    .withMessage(`Invalid role specified. Valid roles are: ${Object.values(USER_ROLES).join(', ')}`),
  body('office')
    .optional()
    .isIn(['bhubaneswar', 'mumbai', 'bangalore', 'delhi'])
    .withMessage('Invalid office location. Valid offices are: bhubaneswar, mumbai, bangalore, delhi'),
  body('phone')
    .optional()
    .isMobilePhone()
    .withMessage('Please provide a valid phone number'),
  body('department')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Department must be between 2 and 100 characters'),
  body('dateOfBirth')
    .optional()
    .isISO8601()
    .withMessage('Date of birth must be a valid date'),
  body('address.street')
    .optional()
    .trim()
    .isLength({ max: 200 })
    .withMessage('Street address cannot exceed 200 characters'),
  body('address.city')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('City cannot exceed 100 characters'),
  body('address.state')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('State cannot exceed 100 characters'),
  body('address.country')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Country cannot exceed 100 characters'),
  body('address.zipCode')
    .optional()
    .trim()
    .isLength({ max: 20 })
    .withMessage('ZIP code cannot exceed 20 characters'),
  auditLog('CREATE_USER')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const {
      firstName,
      lastName,
      email,
      password,
      role,
      office,
      phone,
      department,
      dateOfBirth,
      address
    } = req.body;

    // Check if user already exists
    const existingUser = await User.findOne({ email });
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'User with this email already exists'
      });
    }

    // Create new user
    const userData = {
      firstName,
      lastName,
      email,
      password,
      role: role || USER_ROLES.EMPLOYEE, // Default to employee if not provided
      office: office || 'bhubaneswar', // Default office if not provided
      phone,
      department,
      dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : undefined,
      address: address ? {
        street: address.street,
        city: address.city,
        state: address.state,
        country: address.country,
        zipCode: address.zipCode
      } : undefined
    };

    // Employee ID will be auto-generated by the User model pre-save hook

    const user = new User(userData);
    await user.save();

    // Generate tokens for the new user
    const token = user.generateAuthToken();
    const refreshToken = user.generateRefreshToken();

    // Save refresh token
    user.refreshTokens.push({
      token: refreshToken,
      createdAt: new Date()
    });
    await user.save();

    // Remove sensitive data from response
    const userResponse = user.toObject();
    delete userResponse.password;
    delete userResponse.refreshTokens;
    delete userResponse.biometricData?.faceEncoding;
    delete userResponse.biometricData?.fingerprintHash;

    res.status(201).json({
      success: true,
      message: 'User created successfully',
      data: {
        user: userResponse,
        token,
        refreshToken
      }
    });

  } catch (error) {
    console.error('Create user error:', error);

    if (error.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: Object.values(error.errors).map(err => err.message)
      });
    }

    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      return res.status(400).json({
        success: false,
        message: `${field === 'email' ? 'Email' : 'Employee ID'} already exists`
      });
    }

    res.status(500).json({
      success: false,
      message: 'Server error while creating user'
    });
  }
});

// @route   GET /api/users
// @desc    Get all users with filtering and pagination
// @access  Private (Admin/Manager)
router.get('/', [
  auth,
  authorize(USER_ROLES.ADMIN, USER_ROLES.MANAGER),
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
  query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
  query('role').optional().isIn(Object.values(USER_ROLES)).withMessage('Invalid role'),
  query('office').optional().isIn(['bhubaneswar', 'mumbai', 'bangalore', 'delhi']).withMessage('Invalid office'),
  query('isActive').optional().isBoolean().withMessage('isActive must be boolean')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const {
      page = 1,
      limit = 10,
      search,
      role,
      office,
      department,
      isActive,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = req.query;

    const filter = {};

    // Role-based restrictions
    if (req.user.role === USER_ROLES.MANAGER) {
      filter.office = req.user.office;
      filter.department = req.user.department;
    }

    if (role) filter.role = role;
    if (office && req.user.role === USER_ROLES.ADMIN) filter.office = office;
    if (department) filter.department = department;
    if (isActive !== undefined) filter.isActive = isActive === 'true';

    // Search
    if (search) {
      filter.$or = [
        { firstName: { $regex: search, $options: 'i' } },
        { lastName: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
        { phone: { $regex: search, $options: 'i' } },
        { employeeId: { $regex: search, $options: 'i' } }
      ];
    }

    // Pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);
    const sortOptions = { [sortBy]: sortOrder === 'desc' ? -1 : 1 };

    // Optimized query
    const [users, total] = await Promise.all([
      User.find(filter)
        .sort(sortOptions)
        .skip(skip)
        .limit(parseInt(limit))
        .select('-password -refreshTokens -biometricData.faceEncoding -biometricData.fingerprintHash')
        .lean(), // converts Mongoose docs to plain JS objects
      User.countDocuments(filter)
    ]);

    const totalPages = Math.ceil(total / parseInt(limit));
    const hasNextPage = parseInt(page) < totalPages;
    const hasPrevPage = parseInt(page) > 1;

    return res.json({
      success: true,
      data: {
        users, // clean array of user objects
        pagination: {
          currentPage: parseInt(page),
          totalPages,
          totalUsers: total,
          hasNextPage,
          hasPrevPage,
          limit: parseInt(limit)
        }
      }
    });

  } catch (error) {
    console.error('Get users error:', error);
    return res.status(500).json({
      success: false,
      message: 'Server error while fetching users'
    });
  }
});


// @route   GET /api/users/:id
// @desc    Get user by ID
// @access  Private (Self/Admin/Manager)
router.get('/:id', [auth, managerAccess], async (req, res) => {
  try {
    const user = User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const userObj = { ...user };
    delete userObj.password;
    delete userObj.refreshTokens;
    delete userObj.biometricData?.faceEncoding;
    delete userObj.biometricData?.fingerprintHash;

    res.json({
      success: true,
      data: { user: userObj }
    });
  } catch (error) {
    console.error('Get user error:', error);

    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid user ID format'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Server error while fetching user'
    });
  }
});

// @route   PUT /api/users/:id
// @desc    Update user
// @access  Private (Self/Admin)
router.put('/:id', [
  auth,
  selfOrAdmin,
  body('firstName').optional().trim().isLength({ min: 2, max: 50 }).withMessage('First name must be between 2 and 50 characters'),
  body('lastName').optional().trim().isLength({ min: 2, max: 50 }).withMessage('Last name must be between 2 and 50 characters'),
  body('phone').optional().isMobilePhone().withMessage('Please provide a valid phone number'),
  body('role').optional().isIn(Object.values(USER_ROLES)).withMessage('Invalid role'),
  body('office').optional().isIn(['bhubaneswar', 'mumbai', 'bangalore', 'delhi']).withMessage('Invalid office'),
  auditLog('UPDATE_USER')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const userId = req.params.id;
    const updates = req.body;

    // Remove sensitive fields that shouldn't be updated via this route
    delete updates.password;
    delete updates.refreshTokens;
    delete updates.biometricData;
    delete updates.loginAttempts;
    delete updates.accountLocked;

    // Only admin can update role and certain fields
    if (req.user.role !== USER_ROLES.ADMIN) {
      delete updates.role;
      delete updates.permissions;
      delete updates.isActive;
      delete updates.emailVerified;
    }

    // Users can only update their own profile (except admin)
    if (req.user.role !== USER_ROLES.ADMIN && req.user._id.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'You can only update your own profile'
      });
    }

    const user = User.findByIdAndUpdate(userId, { ...updates, updatedAt: new Date() });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const userObj = { ...user };
    delete userObj.password;
    delete userObj.refreshTokens;
    delete userObj.biometricData?.faceEncoding;
    delete userObj.biometricData?.fingerprintHash;

    res.json({
      success: true,
      message: 'User updated successfully',
      data: { user: userObj }
    });
  } catch (error) {
    console.error('Update user error:', error);

    if (error.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: Object.values(error.errors).map(err => err.message)
      });
    }

    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'Email or employee ID already exists'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Server error while updating user'
    });
  }
});

// @route   DELETE /api/users/:id
// @desc    Delete user (soft delete)
// @access  Private (Admin only)
router.delete('/:id', [
  auth,
  authorize(USER_ROLES.ADMIN),
  auditLog('DELETE_USER')
], async (req, res) => {
  try {
    const userId = req.params.id;

    // Prevent admin from deleting themselves
    if (req.user._id.toString() === userId) {
      return res.status(400).json({
        success: false,
        message: 'You cannot delete your own account'
      });
    }

    const user = User.findByIdAndUpdate(userId, {
      isActive: false,
      deletedAt: new Date(),
      refreshTokens: [] // Clear all sessions
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    res.json({
      success: true,
      message: 'User deleted successfully'
    });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while deleting user'
    });
  }
});

// @route   POST /api/users/:id/upload-profile-image
// @desc    Upload profile image
// @access  Private (Self/Admin)
router.post('/:id/upload-profile-image', [
  auth,
  selfOrAdmin,
  upload.profileImage,
  upload.addFileInfo
], async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No image file provided'
      });
    }

    const userId = req.params.id;
    const imageUrl = upload.getFileUrl(req.file.filename, 'profiles');

    // Delete old profile image if exists
    const user = User.findById(userId);
    if (user && user.profileImage) {
      const oldImagePath = user.profileImage.replace('/api/uploads/profiles/', '');
      upload.deleteFile(path.join(upload.uploadDirs.profiles, oldImagePath));
    }

    // Update user with new profile image
    const updatedUser = User.findByIdAndUpdate(userId, {
      profileImage: imageUrl,
      updatedAt: new Date()
    });

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const userObj = { ...updatedUser };
    delete userObj.password;
    delete userObj.refreshTokens;
    delete userObj.biometricData?.faceEncoding;
    delete userObj.biometricData?.fingerprintHash;

    res.json({
      success: true,
      message: 'Profile image uploaded successfully',
      data: {
        user: userObj,
        imageUrl
      }
    });
  } catch (error) {
    console.error('Upload profile image error:', error);

    // Clean up uploaded file on error
    if (req.file) {
      upload.deleteFile(req.file.path);
    }

    res.status(500).json({
      success: false,
      message: 'Server error while uploading profile image'
    });
  }
});

// @route   POST /api/users/:id/enroll-biometric
// @desc    Enroll biometric data
// @access  Private (Self/Admin)
router.post('/:id/enroll-biometric', [
  auth,
  selfOrAdmin,
  upload.biometricImage,
  upload.addFileInfo
], async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No biometric image provided'
      });
    }

    const userId = req.params.id;
    const { biometricType = 'face' } = req.body;

    // TODO: Process biometric image and extract features
    // For now, just store the image path

    const biometricData = {
      isEnrolled: true,
      enrolledAt: new Date(),
      biometricType,
      imagePath: req.file.path,
      // In production, store processed biometric features here
      faceEncoding: 'mock_face_encoding_data',
      fingerprintHash: biometricType === 'fingerprint' ? 'mock_fingerprint_hash' : undefined
    };

    const user = User.findByIdAndUpdate(userId, {
      biometricData,
      updatedAt: new Date()
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const userObj = { ...user };
    delete userObj.password;
    delete userObj.refreshTokens;
    delete userObj.biometricData?.faceEncoding;
    delete userObj.biometricData?.fingerprintHash;

    res.json({
      success: true,
      message: 'Biometric enrollment successful',
      data: {
        user: userObj,
        biometricType
      }
    });
  } catch (error) {
    console.error('Biometric enrollment error:', error);

    // Clean up uploaded file on error
    if (req.file) {
      upload.deleteFile(req.file.path);
    }

    res.status(500).json({
      success: false,
      message: 'Server error during biometric enrollment'
    });
  }
});

// @route   GET /api/users/stats/overview
// @desc    Get user statistics overview
// @access  Private (Admin/Manager)
router.get('/stats/overview', [auth, authorize(USER_ROLES.ADMIN, USER_ROLES.MANAGER)], async (req, res) => {
  try {
    const filter = {};

    // Managers can only see stats from their office
    if (req.user.role === USER_ROLES.MANAGER) {
      filter.office = req.user.office;
    }

    const allUsers = User.find(filter);
    const totalUsers = allUsers.length;
    const activeUsers = allUsers.filter(user => user.isActive).length;

    // Calculate role distribution
    const roleStats = allUsers.reduce((acc, user) => {
      acc[user.role] = (acc[user.role] || 0) + 1;
      return acc;
    }, {});

    // Calculate office distribution
    const officeStats = allUsers.reduce((acc, user) => {
      acc[user.office] = (acc[user.office] || 0) + 1;
      return acc;
    }, {});

    const stats = {
      totalUsers,
      activeUsers,
      inactiveUsers: totalUsers - activeUsers,
      roleDistribution: roleStats,
      officeDistribution: officeStats
    };

    res.json({
      success: true,
      data: { stats }
    });
  } catch (error) {
    console.error('Get user stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while fetching user statistics'
    });
  }
});

// @route   PUT /api/users/:id/toggle-status
// @desc    Toggle user active status
// @access  Private (Admin only)
router.put('/:id/toggle-status', [
  auth,
  authorize(USER_ROLES.ADMIN),
  auditLog('TOGGLE_USER_STATUS')
], async (req, res) => {
  try {
    const userId = req.params.id;

    // Prevent admin from deactivating themselves
    if (req.user._id.toString() === userId) {
      return res.status(400).json({
        success: false,
        message: 'You cannot deactivate your own account'
      });
    }

    const user = User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const updatedUser = User.findByIdAndUpdate(userId, {
      isActive: !user.isActive,
      refreshTokens: !user.isActive ? [] : user.refreshTokens
    });

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    res.json({
      success: true,
      message: `User ${updatedUser.isActive ? 'activated' : 'deactivated'} successfully`,
      data: {
        userId: updatedUser._id,
        isActive: updatedUser.isActive
      }
    });
  } catch (error) {
    console.error('Toggle user status error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while toggling user status'
    });
  }
});

module.exports = router;